import asyncio
import json
import logging
import datetime
import uuid
import subprocess
import ipaddress
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
import sqlite3
import threading
import requests

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class VulnerabilityStatus(Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    FIXED = "fixed"
    FALSE_POSITIVE = "false_positive"
    ACCEPTED_RISK = "accepted_risk"

@dataclass
class Vulnerability:
    id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    affected_host: str
    affected_service: Optional[str]
    port: Optional[int]
    protocol: Optional[str]
    status: VulnerabilityStatus
    first_detected: str
    last_seen: str
    remediation: Optional[str]
    references: List[str]
    tags: List[str]
    risk_score: int
    exploitability: str
    patch_available: bool

@dataclass
class ScanResult:
    scan_id: str
    target: str
    scan_type: str
    start_time: str
    end_time: Optional[str]
    status: str
    vulnerabilities_found: int
    progress: int
    scanner: str
    profile: str

class VulnerabilityManager:
    """Enterprise vulnerability management system"""
    
    def __init__(self, config: Dict[str, Any], socketio=None):
        self.config = config
        self.socketio = socketio
        self.db_path = "vulnerabilities.db"
        self.active_scans = {}
        self.scan_lock = threading.Lock()
        
        # Initialize database
        self._init_database()
        
        # CVE API configuration
        self.cve_api_base = "https://cve.circl.lu/api/cve"
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        
        logger.info("Vulnerability Manager initialized")
    
    def _init_database(self):
        """Initialize vulnerability database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Create vulnerabilities table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id TEXT PRIMARY KEY,
                    cve_id TEXT,
                    title TEXT NOT NULL,
                    description TEXT,
                    severity TEXT NOT NULL,
                    cvss_score REAL,
                    affected_host TEXT NOT NULL,
                    affected_service TEXT,
                    port INTEGER,
                    protocol TEXT,
                    status TEXT NOT NULL,
                    first_detected TEXT NOT NULL,
                    last_seen TEXT NOT NULL,
                    remediation TEXT,
                    references TEXT,
                    tags TEXT,
                    risk_score INTEGER,
                    exploitability TEXT,
                    patch_available BOOLEAN
                )
            ''')
            
            # Create scans table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scans (
                    scan_id TEXT PRIMARY KEY,
                    target TEXT NOT NULL,
                    scan_type TEXT NOT NULL,
                    start_time TEXT NOT NULL,
                    end_time TEXT,
                    status TEXT NOT NULL,
                    vulnerabilities_found INTEGER DEFAULT 0,
                    progress INTEGER DEFAULT 0,
                    scanner TEXT NOT NULL,
                    profile TEXT NOT NULL
                )
            ''')
            
            # Create remediation tracking table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS remediation_tracking (
                    id TEXT PRIMARY KEY,
                    vulnerability_id TEXT NOT NULL,
                    action_taken TEXT NOT NULL,
                    assigned_to TEXT,
                    due_date TEXT,
                    completed_date TEXT,
                    notes TEXT,
                    FOREIGN KEY (vulnerability_id) REFERENCES vulnerabilities (id)
                )
            ''')
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Database initialization error: {e}")
    
    def start_vulnerability_scan(self, targets: List[str], scan_profile: str = "standard") -> str:
        """Start a comprehensive vulnerability scan"""
        scan_id = str(uuid.uuid4())
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=", ".join(targets),
            scan_type="vulnerability",
            start_time=datetime.datetime.now().isoformat(),
            end_time=None,
            status="running",
            vulnerabilities_found=0,
            progress=0,
            scanner="nmap",
            profile=scan_profile
        )
        
        with self.scan_lock:
            self.active_scans[scan_id] = scan_result
        
        # Save scan to database
        self._save_scan_to_db(scan_result)
        
        # Start scan in background thread
        scan_thread = threading.Thread(
            target=self._run_vulnerability_scan,
            args=(scan_id, targets, scan_profile),
            daemon=True
        )
        scan_thread.start()
        
        return scan_id
    
    def _run_vulnerability_scan(self, scan_id: str, targets: List[str], profile: str):
        """Run the actual vulnerability scan"""
        try:
            scan_result = self.active_scans.get(scan_id)
            if not scan_result:
                return
            
            total_targets = len(targets)
            vulnerabilities_found = 0
            
            for i, target in enumerate(targets):
                # Update progress
                progress = int((i / total_targets) * 90)  # Reserve 10% for final processing
                scan_result.progress = progress
                self._update_scan_progress(scan_id, progress)
                
                # Emit progress update
                if self.socketio:
                    self.socketio.emit('scan_progress', {
                        'scan_id': scan_id,
                        'progress': progress,
                        'current_target': target
                    })
                
                # Perform nmap scan
                nmap_vulns = self._run_nmap_vuln_scan(target, profile)
                
                # Process vulnerabilities
                for vuln in nmap_vulns:
                    vuln_id = self._save_vulnerability(vuln)
                    vulnerabilities_found += 1
                
                # Perform service-specific scans
                service_vulns = self._scan_services(target)
                for vuln in service_vulns:
                    vuln_id = self._save_vulnerability(vuln)
                    vulnerabilities_found += 1
            
            # Final processing
            scan_result.progress = 100
            scan_result.status = "completed"
            scan_result.end_time = datetime.datetime.now().isoformat()
            scan_result.vulnerabilities_found = vulnerabilities_found
            
            self._update_scan_completion(scan_id, scan_result)
            
            # Emit completion
            if self.socketio:
                self.socketio.emit('scan_completed', {
                    'scan_id': scan_id,
                    'vulnerabilities_found': vulnerabilities_found,
                    'duration': scan_result.end_time
                })
            
        except Exception as e:
            logger.error(f"Vulnerability scan error: {e}")
            if scan_id in self.active_scans:
                self.active_scans[scan_id].status = "failed"
                self._update_scan_status(scan_id, "failed")
    
    def _run_nmap_vuln_scan(self, target: str, profile: str) -> List[Vulnerability]:
        """Run nmap vulnerability scripts"""
        vulnerabilities = []
        
        try:
            # Determine nmap options based on profile
            if profile == "aggressive":
                nmap_options = "-sS -sV -O --script vuln --script-timeout 30s"
            elif profile == "stealth":
                nmap_options = "-sS -T2 --script vuln --script-timeout 60s"
            else:  # standard
                nmap_options = "-sS -sV --script vuln --script-timeout 45s"
            
            # Run nmap scan
            cmd = f"nmap {nmap_options} {target}"
            result = subprocess.run(
                cmd.split(),
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            if result.returncode == 0:
                vulnerabilities = self._parse_nmap_vulnerabilities(result.stdout, target)
            
        except subprocess.TimeoutExpired:
            logger.warning(f"Nmap scan timeout for target: {target}")
        except Exception as e:
            logger.error(f"Nmap scan error for {target}: {e}")
        
        return vulnerabilities
    
    def _parse_nmap_vulnerabilities(self, nmap_output: str, target: str) -> List[Vulnerability]:
        """Parse nmap output for vulnerabilities"""
        vulnerabilities = []
        
        try:
            lines = nmap_output.split('\n')
            current_port = None
            current_service = None
            
            for line in lines:
                line = line.strip()
                
                # Extract port and service info
                if "/tcp" in line or "/udp" in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        port_info = parts[0]
                        current_port = int(port_info.split('/')[0])
                        if len(parts) >= 3:
                            current_service = parts[2]
                
                # Look for vulnerability indicators
                if "VULNERABLE" in line.upper() or "CVE-" in line:
                    vuln = self._create_vulnerability_from_nmap(
                        line, target, current_port, current_service
                    )
                    if vuln:
                        vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error parsing nmap vulnerabilities: {e}")
        
        return vulnerabilities
    
    def _create_vulnerability_from_nmap(self, line: str, host: str, port: Optional[int], service: Optional[str]) -> Optional[Vulnerability]:
        """Create vulnerability object from nmap output line"""
        try:
            vuln_id = str(uuid.uuid4())
            now = datetime.datetime.now().isoformat()
            
            # Extract CVE if present
            cve_id = None
            if "CVE-" in line:
                import re
                cve_match = re.search(r'CVE-\d{4}-\d{4,}', line)
                if cve_match:
                    cve_id = cve_match.group()
            
            # Determine severity based on keywords
            severity = VulnerabilitySeverity.MEDIUM
            cvss_score = 5.0
            
            if any(keyword in line.upper() for keyword in ["CRITICAL", "HIGH", "EXPLOIT"]):
                severity = VulnerabilitySeverity.HIGH
                cvss_score = 7.5
            elif any(keyword in line.upper() for keyword in ["MEDIUM"]):
                severity = VulnerabilitySeverity.MEDIUM
                cvss_score = 5.0
            elif any(keyword in line.upper() for keyword in ["LOW", "INFO"]):
                severity = VulnerabilitySeverity.LOW
                cvss_score = 2.5
            
            vuln = Vulnerability(
                id=vuln_id,
                cve_id=cve_id,
                title=f"Vulnerability detected on {service or 'unknown service'}",
                description=line.strip(),
                severity=severity,
                cvss_score=cvss_score,
                affected_host=host,
                affected_service=service,
                port=port,
                protocol="tcp",
                status=VulnerabilityStatus.OPEN,
                first_detected=now,
                last_seen=now,
                remediation=None,
                references=[],
                tags=["nmap", "automated"],
                risk_score=int(cvss_score * 10),
                exploitability="unknown",
                patch_available=False
            )
            
            return vuln
            
        except Exception as e:
            logger.error(f"Error creating vulnerability from nmap: {e}")
            return None
    
    def _scan_services(self, target: str) -> List[Vulnerability]:
        """Perform service-specific vulnerability scans"""
        vulnerabilities = []
        
        # This would include checks for:
        # - Web application vulnerabilities
        # - Database vulnerabilities
        # - SSH/RDP vulnerabilities
        # - Network service vulnerabilities
        
        # For now, return empty list - can be extended with specific scanners
        return vulnerabilities
    
    def _save_vulnerability(self, vulnerability: Vulnerability) -> str:
        """Save vulnerability to database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO vulnerabilities 
                (id, cve_id, title, description, severity, cvss_score, affected_host,
                 affected_service, port, protocol, status, first_detected, last_seen,
                 remediation, references, tags, risk_score, exploitability, patch_available)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                vulnerability.id,
                vulnerability.cve_id,
                vulnerability.title,
                vulnerability.description,
                vulnerability.severity.value,
                vulnerability.cvss_score,
                vulnerability.affected_host,
                vulnerability.affected_service,
                vulnerability.port,
                vulnerability.protocol,
                vulnerability.status.value,
                vulnerability.first_detected,
                vulnerability.last_seen,
                vulnerability.remediation,
                json.dumps(vulnerability.references),
                json.dumps(vulnerability.tags),
                vulnerability.risk_score,
                vulnerability.exploitability,
                vulnerability.patch_available
            ))
            
            conn.commit()
            conn.close()
            
            return vulnerability.id
            
        except Exception as e:
            logger.error(f"Error saving vulnerability: {e}")
            return None
    
    def get_vulnerabilities(self, severity_filter: Optional[str] = None, limit: int = 50) -> List[Dict]:
        """Get vulnerabilities from database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            query = "SELECT * FROM vulnerabilities"
            params = []
            
            if severity_filter:
                query += " WHERE severity = ?"
                params.append(severity_filter)
            
            query += " ORDER BY cvss_score DESC LIMIT ?"
            params.append(limit)
            
            cursor.execute(query, params)
            rows = cursor.fetchall()
            
            # Convert to dictionaries
            columns = [desc[0] for desc in cursor.description]
            vulnerabilities = []
            
            for row in rows:
                vuln_dict = dict(zip(columns, row))
                # Parse JSON fields
                vuln_dict['references'] = json.loads(vuln_dict.get('references', '[]'))
                vuln_dict['tags'] = json.loads(vuln_dict.get('tags', '[]'))
                vulnerabilities.append(vuln_dict)
            
            conn.close()
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Error getting vulnerabilities: {e}")
            return []
    
    def get_scan_status(self, scan_id: str) -> Dict:
        """Get status of a vulnerability scan"""
        if scan_id in self.active_scans:
            scan = self.active_scans[scan_id]
            return asdict(scan)
        
        # Check database for completed scans
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM scans WHERE scan_id = ?", (scan_id,))
            row = cursor.fetchone()
            
            if row:
                columns = [desc[0] for desc in cursor.description]
                return dict(zip(columns, row))
            
            conn.close()
            
        except Exception as e:
            logger.error(f"Error getting scan status: {e}")
        
        return {"error": "Scan not found"}
    
    def _save_scan_to_db(self, scan: ScanResult):
        """Save scan result to database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO scans 
                (scan_id, target, scan_type, start_time, end_time, status,
                 vulnerabilities_found, progress, scanner, profile)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                scan.scan_id,
                scan.target,
                scan.scan_type,
                scan.start_time,
                scan.end_time,
                scan.status,
                scan.vulnerabilities_found,
                scan.progress,
                scan.scanner,
                scan.profile
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error saving scan to database: {e}")
    
    def _update_scan_progress(self, scan_id: str, progress: int):
        """Update scan progress"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute(
                "UPDATE scans SET progress = ? WHERE scan_id = ?",
                (progress, scan_id)
            )
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error updating scan progress: {e}")
    
    def _update_scan_completion(self, scan_id: str, scan_result: ScanResult):
        """Update scan completion"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                UPDATE scans 
                SET end_time = ?, status = ?, vulnerabilities_found = ?, progress = ?
                WHERE scan_id = ?
            ''', (
                scan_result.end_time,
                scan_result.status,
                scan_result.vulnerabilities_found,
                scan_result.progress,
                scan_id
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error updating scan completion: {e}")
    
    def _update_scan_status(self, scan_id: str, status: str):
        """Update scan status"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute(
                "UPDATE scans SET status = ? WHERE scan_id = ?",
                (status, scan_id)
            )
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error updating scan status: {e}")
    
    def get_vulnerability_statistics(self) -> Dict:
        """Get vulnerability statistics"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Get counts by severity
            cursor.execute('''
                SELECT severity, COUNT(*) as count 
                FROM vulnerabilities 
                WHERE status != 'fixed'
                GROUP BY severity
            ''')
            severity_counts = dict(cursor.fetchall())
            
            # Get total count
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities WHERE status != 'fixed'")
            total_open = cursor.fetchone()[0]
            
            # Get recent vulnerabilities (last 7 days)
            week_ago = (datetime.datetime.now() - datetime.timedelta(days=7)).isoformat()
            cursor.execute(
                "SELECT COUNT(*) FROM vulnerabilities WHERE first_detected >= ?",
                (week_ago,)
            )
            recent_count = cursor.fetchone()[0]
            
            conn.close()
            
            return {
                "total_open": total_open,
                "recent_vulnerabilities": recent_count,
                "by_severity": severity_counts,
                "risk_score": self._calculate_overall_risk_score(severity_counts)
            }
            
        except Exception as e:
            logger.error(f"Error getting vulnerability statistics: {e}")
            return {}
    
    def _calculate_overall_risk_score(self, severity_counts: Dict) -> int:
        """Calculate overall risk score"""
        weights = {
            "critical": 10,
            "high": 7,
            "medium": 4,
            "low": 1,
            "info": 0
        }
        
        score = 0
        for severity, count in severity_counts.items():
            score += weights.get(severity, 0) * count
        
        return min(score, 100)  # Cap at 100
    
    def update_vulnerability_status(self, vuln_id: str, status: str, notes: Optional[str] = None) -> bool:
        """Update vulnerability status"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute(
                "UPDATE vulnerabilities SET status = ? WHERE id = ?",
                (status, vuln_id)
            )
            
            # Add to remediation tracking if fixing
            if status == "fixed" and notes:
                cursor.execute('''
                    INSERT INTO remediation_tracking 
                    (id, vulnerability_id, action_taken, completed_date, notes)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    str(uuid.uuid4()),
                    vuln_id,
                    "Vulnerability fixed",
                    datetime.datetime.now().isoformat(),
                    notes
                ))
            
            conn.commit()
            conn.close()
            
            return True
            
        except Exception as e:
            logger.error(f"Error updating vulnerability status: {e}")
            return False
